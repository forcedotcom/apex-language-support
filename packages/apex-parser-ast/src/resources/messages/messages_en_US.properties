#
# Copyright 2017 salesforce.com, inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#

time.string=\ HH must be 00-23, MM must be 00-59, and SS must be 00-59. .NNN is optional and is the milliseconds within the second 000-999. OFFSET is the timezone offset and has an optional + or - followed by HHMM or HH\:MM.
date.string=\ YYYY must be a year (AD) 0001-9999. mm must be a month 01-12. DD must be a day 01-31.

real.loc=startIndex: {0} endIndex: {1} line: {2} column: {3}
synthetic.loc=no location

unexpected.symbol.expected.found=Unexpected symbol ''{0}'', was expecting ''{1}''.
unexpected.syntax.error=Unexpected syntax error: {0}.
unexpected.symbol.range=Unexpected symbol ''{0}'', was expected something in the range ''{1}''..''{2}''.
unexpected.symbol.not.set=Unexpected symbol ''{0}'', was NOT expecting anything in the set [{1}].
unexpected.symbol.set=Unexpected symbol ''{0}'', was expecting something in the set [{1}].
unrecognized.symbol.not.valid.apex.identifier=Unrecognized symbol ''{0}'', which is not a valid Apex identifier.
unexpected.eof=Unexpected <EOF>
illegal.integer.literal=Illegal integer
illegal.long.literal=Illegal long
illegal.double.literal=Illegal double
illegal.decimal.literal=Illegal decimal
illegal.string.literal=Illegal string literal: {0}
missing.syntax=Missing ''{1}'' at {0}
unexpected.token=Unexpected token {0}.
unmatched.syntax=Extra ''{1}'', at {0}.
mismatched.syntax=Expecting ''{1}'' but was: {0}

missing.closing.quote=Missing closing quote character {0} on string.
missing.closing.mark=Missing closing mark {0} on multi-line comment.

invalid.apex.identifier=Invalid identifier ''{0}''. Apex identifiers must start with an ASCII letter (a-z or A-Z) followed by any number of ASCII letters (a-z or A-Z), digits (0 - 9), ''_''.
invalid.apex.symbol=Found punctuation symbol or operator ''{0}'' that isn''t valid in Apex.
invalid.control.character=Found control character hex 0x{0} (decimal {1}) that isn''t valid in Apex.
invalid.time=Invalid Time ''{0}''. Apex times must be of the form HH:MM:SS.NNNzOFFSET.{1}
invalid.date=Invalid Date ''{0}''. If you are trying to do subtraction adding spaces around the ''-'' sign(s) will help. Apex dates must be of the form YYYY-mm-DD.{1}
invalid.date.time=Invalid DateTime ''{0}''. Apex DateTimes must be of the form YYYY-mm-DDtHH:MM:SS.NNNzOFFSET.{1}{2}
invalid.string.literal.illegal.last.character=Invalid string literal ''{0}''.  '\\' is not allowed as the last character in a string literal.
invalid.string.literal.illegal.character.sequence=Invalid string literal ''{0}''. Illegal character sequence '\\'{1}'' in string literal.
invalid.string.literal.illegal.unicode.sequence=Invalid string literal ''{0}''. Illegal unicode sequence. Less than four hex digits '\\'{1}'' in string literal.
invalid.string.literal.illegal.unicode=Invalid string literal ''{0}''. Illegal unicode sequence. '\\u'{1}'' in string literal.
invalid.string.literal.illegal.linebreaks=Line breaks are not allowed in string literals

sobject.not.constructable=SObject is not constructable: {0}
invalid.row.lock=Cannot lock rows for an SObject type that can not be updated: {0}
invalid.dml.type=DML requires SObject or SObject list type: {0}
dml.operation.not.allowed=DML operation {0} not allowed on {1}
upsert.requires.concrete.type=Upsert with a field specification requires a concrete SObject type
upsert.invalid.field=Invalid field for upsert, must be an External Id custom or standard indexed field: {0}
merge.not.supported=Specified type {0} cannot be merged
merge.requires.concrete.type=Merge requires a concrete SObject type: {0}
invalid.merge.duplicate.records=Invalid type for duplicate records

invalid.super.type=Invalid super type: {0}
circular.definition=Circular definition: {0}
invalid.interface=Invalid interface: {0}
generic.interface.already.implemented=Generic Interface already implemented: {0}
interface.already.implemented=Interface already implemented: {0}
type.must.be.top.level=Only top-level classes can implement {0}
invalid.parameterized.type=Invalid parameterized type: {0}
invalid.parameterized.type.count=Invalid type argument count for {0}: expected {1} but found {2}
type.arguments.for.non.parameterized.type=Type arguments provided for a non-parameterized type: {0}
no.type.arguments.for.parameterized.type=No type arguments provided for a parameterized type: {0}
parameterized.type.too.deep=Exceeded max parameterized type depth: {0}, depth: {1}
maximum.type.depth.exceeded=Maximum type depth exceeded: 10
invalid.class=Invalid class: {0}
array.ref.not.allowed=A type is not allowed to extend or implement an array ref: {0}
invalid.inner.type.no.inner.types=Inner types are not allowed to have inner types
invalid.inner.type.no.static.blocks=Inner types are not allowed to have static blocks
invalid.final.super.type=Non-virtual and non-abstract type cannot be extended: {0}

invalid.runas=runAs requires a single argument of type 'User' or 'Version'
max.enums.exceeded=Maximum number of enum items exceeded: {0}

invalid.exception.must.end.with.exception=Classes extending Exception must have a name ending in 'Exception': {0}
invalid.exception.must.extend.exception=Exception class must extend another Exception class: {0}
invalid.expression.statement=Expression cannot be a statement.
duplicate.variable=Duplicate variable: {0}
duplicate.field=Duplicate field: {0}
variable.does.not.exist=Variable does not exist: {0}
external.string.does.not.exist=External string does not exist: {0}
page.does.not.exist=Page does not exist: {0}
invalid.static.variable.context=Static field cannot be referenced from a non static context: {0} from the type {1}
invalid.non.static.variable.context=Non static field cannot be referenced from a static context: {0} from the type {1}
invalid.final.field.assignment=Final members can only be assigned in their declaration, init blocks, or constructors: {0}
invalid.field.type.store=A value cannot be stored to {0} in type {1}
invalid.field.type.load=A value cannot be read from {0} in type {1}
illegal.non.foreign.key.reference=A non foreign key field cannot be referenced in a path expression: {0}
illegal.forward.reference=Illegal forward reference: {0}

invalid.continue=Continue statement must be in loop
invalid.break=Break statement must be in loop
loop.must.iterate.over.collection=Loop must iterate over collection: {0}
invalid.loop.type=Invalid loop variable type expected {0} was {1}
loop.with.query.requires.statement=Loop with query must provide a statement
loop.variable.mismatch.concrete.sobject.type=Loop variable must be a generic SObject or List or a concrete SObject or List of: {0}
loop.variable.mismatch.sobject.type=Loop variable must be a generic SObject or List or a concrete SObject or List.

invalid.comparison.types=Comparison arguments must be compatible types: {0}, {1}
invalid.logical.type=Logical operator can only be applied to {0}
invalid.inequality.type=Inequality operator not allowed for this type: {0}
invalid.exact.equality.type=Exact equality operator only allowed for reference types: {0}

invalid.numeric.arguments.expression=Arithmetic expressions must use numeric arguments
invalid.time.operand.expression=Time expressions must use Integer or Long
invalid.date.operand.expression=Date expressions must use Integer or Long
invalid.datetime.operand.expression=Date/time expressions must use Integer or Double or Decimal
invalid.shift.operator.arguments={0} operation can only be applied to Integer or Long types
invalid.bitwise.operator.arguments={0} operator can only be applied to Boolean expressions or to Integer or Long expressions
invalid.void.arithmetic.expression=Arithmetic expressions are not allowed on void types

invalid.boolean.prefix.operand={0} operator can only be applied to boolean expressions
invalid.negate.prefix.operand=Unary negation must use a numeric argument
invalid.numeric.prefix.decrement=Unary prefix decrement can only be applied to numeric expressions: {0}
invalid.numeric.prefix.increment=Unary prefix increment can only be applied to numeric expressions: {0}
invalid.type.bitwise.negate=Invalid type for bitwise negate: {0}
incompatible.cast.types=Incompatible types since an instance of {0} is never an instance of {1}
invalid.cast.type=Operation cast is not allowed on type: {0}

invalid.numeric.postfix.operand=Unary postfix increment/decrement can only be applied to numeric expressions: {0}

invalid.condition.type=Condition expression must be of type Boolean: {0}
incompatible.ternary.expression.types=Incompatible types in ternary operator: {0}, {1}
incompatible.nullcoalescing.expression.types=Incompatible types in null coalescing operator: {0}, {1}

# new expression errors, (set, lists, maps, objects, and name value pair)
invalid.list.initializer=Invalid initializer type {0} found for List<{1}>: expected an Integer or a List of type {1}
invalid.set.initializer=Invalid initializer type {0} found for Set<{1}>: expected a List or a Set of type: {1}
invalid.map.initializer=Invalid initializer type {0} found for Map<{1},{2}>: expected a Map with the same key and value types, or a valid SObject List
invalid.list.initial.expression.type=Initial expression is of incorrect type, expected: {0} but was: {1}
invalid.set.initial.expression.type=Initial expression is of incorrect type, expected: {0} but was: {1}
invalid.sobject.list=Only concrete SObject lists can be created
invalid.sobject.map=Only concrete SObject maps can be created
invalid.initial.key.type=Invalid key type {0} for {1}
invalid.initial.value.type=Invalid value type {0} for {1}
invalid.list.type=Expression must be a list type: {0}
invalid.list.index.type=List index must be of type {0}: {1}
invalid.new.abstract=Abstract classes cannot be constructed: {0}

# error messages for specific collection type methods or from method validators
invalid.map.putAll=Invalid putAll type {0} found for {1}
illegal.all.call=Illegal all method call for argument type, {0}, for collection: {1}
illegal.comparator.for.sort=Incompatible Comparator argument type: {0}, for collection: {1}
method.invalid.sobject.map=Operation only applies to SObject value map types: {0}
method.invalid.sobject.list=Operation only applies to SObject list types: {0}
method.invalid.add.error.not.sobject.field=addError must be invoked on an expression that is an exact SObject field reference
method.invalid.on.sobject.field=Method {0} must be invoked on an expression that is an exact SObject field reference
method.invalid.add.error.not.sobject.scalar.field=addError must be invoked on an SObject scalar field
safe.navigation.invalid.between.sobject.field.and.add.error=Safe navigation operator is not allowed between SObject field and addError
safe.navigation.invalid.between.sobject.field.and.method=Safe navigation operator is not allowed between SObject field and {0}

illegal.conversion=Illegal conversion from {0} to {1}
illegal.assignment=Type mismatch: cannot assign {0} to {1}
invalid.expression.assignment=Expression cannot be assigned
invalid.unresolved.type=Invalid type: {0}
type.not.constructable=Type cannot be constructed: {0}
unknown.constructor=Constructor not defined: [{0}].<Constructor>{1}
invalid.name.value.pair.constructor=Invalid constructor syntax, name=value pairs can only be used for SObjects: {0}
invalid.normal.constructor=Type requires name=value pair construction: {0}
field.does.not.exist=Field does not exist: {0} on {1}
field.access.receiver.unresolved=Unable to resolve receiver type for field access: {0}
duplicate.field.init=Duplicate field initialization: {0}

invalid.throw.exception=Throw expression must be of type exception: {0}
invalid.catch.exception=Catch block variable must be of type exception: {0}
invalid.try.needs.catch.or.finally=Try block must have at least one catch block or a finally block
invalid.catch.duplicate.exception=Exception type already caught: {0}

# error messages for switch statement and when blocks
illegal.switch.expression.type={0} is not a valid switch expression type
illegal.no.when.blocks=Switch statement requires at least one when block
when.else.not.last='when else' must be the last when block
illegal.non.when.type=Switching on SObject types must be a 'when type variable' or 'when null'
illegal.when.type={0} cannot be a 'when type variable' block
invalid.already.match.type= {0} in the 'when expression' is already matching the switch expression type
invalid.when.expression.type={0} value in 'when expression' cannot be implicitly converted to the {1} type in switch expression
invalid.fully.qualified.enum=Enum value used in 'when expression' should be unqualified
invalid.switch.enum=Field must be an enum reference
invalid.when.field.constant=Field must be a static final constant: {0}
invalid.when.field.literal=Field must be a non null literal: {0}
invalid.when.literal.expression='when expression' must be a literal, a constant literal field or enum value
not.unique.when.value.or.type={0} occurs as more than one when branch for this switch statement
when.clause.literal.or.valid.constant=When clause must be a literal or a non null constant literal: {0}

invalid.constructor.name=Invalid constructor name: {0}
invalid.number.parameters=Invalid number of parameters exceeds: {0}
invalid.return.non.void=Missing return statement required return type: {0}
invalid.return.void=Void method must not return a value
invalid.void.parameter=Parameters cannot be of type void
unreachable.statement=Unreachable statement
invalid.return.from.non.method=Return must be called from a method
invalid.constructor.return=Constructors must not return a value
invalid.trigger.return=Trigger bodies must not return a value
ambiguous.method.signature=Ambiguous method signature: {0}

# java type, java static method, and java static variable errors
illegal.java.expression=Java expression only allowed for trusted sources
invalid.java.expression=Java expression requires class.field or class.method
invalid.java.expression.class.not.found=Java class not found: {0}
invalid.java.expression.field.not.found=Java field not found: {0} from the type {1}
invalid.java.expression.method.not.found=Java method not found: {0} from the type {1}
invalid.java.expression.method.not.static=Java method not static: {0} from the type {1}

invalid.trigger.object=Trigger type isn''t an SObject: {0}
trigger.not.supported=SObject type does not allow triggers: {0}
invalid.trigger.platform.event=Platform Event SObjects only supports after insert: {0}

# identifier errors
invalid.character.identifier=Invalid character in identifier: {0}
invalid.reserved.name.identifier=Identifier name is reserved: {0}
invalid.reserved.type.identifier=Identifier type is reserved: {0}
identifier.too.long=Identifier name is too long: {0}
invalid.keyword.identifier=Identifier cannot be a keyword: {0}

invalid.void.variable=Variables cannot be of type void
invalid.void.property=Properties cannot be of type void

# super and this errors
invalid.super.static.context=Super cannot be referenced in a static context
invalid.this.static.context=This cannot be referenced in a static context
no.super.type=No super type defined: {0}
invalid.constructor=No constructor defined: {0}
invalid.super.call=Call to 'super()' must be the first statement in a constructor method
invalid.this.call=Call to 'this()' must be the first statement in a constructor method
invalid.default.constructor=No default constructor available in super type: {0}
illegal.instance.method.reference.in.constructor=Cannot reference instance methods in a constructor invocation: {0}
illegal.instance.variable.reference.in.constructor=Cannot reference instance variables in a constructor invocation: {0}

# virtual table errors, similar to modifier errors but these happen when we discover the parent hierarchy
methods.must.override=Method must use the override keyword: {0}
method.does.not.override=@Override specified for non-overriding method: {0}
cannot.reduce.method.visibility.override=Cannot reduce the visibility of method: {0}
non.virtual.methods.cannot.override=Non-virtual, non-abstract methods cannot be overridden: {0}
cannot.override.static.method=Cannot override static method: {0} with {1}

# errors adding methods to the method table
method.types.clash=Method return types clash: {0} vs {1} from the type {2}
method.already.exists=Method already defined: {0} {1} from the type {2}
invalid.method.not.found=Method does not exist or incorrect signature: {0} from the type {1}
invalid.static.method.context=Static method cannot be referenced from a non static context: {0}
invalid.non.static.method.context=Non static method cannot be referenced from a static context: {0}
invalid.abstract.method.call=Abstract method cannot be called directly: {0}
invalid.unit=Invalid unit

# modifier validation errors
# TODO actually show what has multiple scopes...
declarations.single.scope=Declarations can only have one scope
modifier.not.in.top.level.type={0} can only be used on {1} of a top level type
modifier.not.on.top.level.type={0} can only be used on a top level type
modifier.is.not.allowed={0} is not allowed on {1}
modifier.is.internal={0} annotation can only be used by Salesforce code
modifier.illegal.defining.type.for=Defining type for {0}
modifier.illegal.defining.type={0} is not allowed in {1}
modifier.is.by.default={0} are by default {1}
modifier.requires={0} {1} must be declared as {2}
modifier.require.at.least={0} {1} require at least one of the following {2}
modifier.cannot.be={0} {1} cannot be {2}
defining.type.requires={0} defined types requires that {1}
invalid.new.protected.method=New protected methods cannot be defined in non-virtual classes
method.does.not.support.return.type={0} methods do not support return type of {1}
method.does.not.support.parameter.type={0} methods do not support parameter type of {1}
modifier.min.version={0} {1} must be in version {2} or higher
not.visible.min.version={0} not added until version {2}: {1}
not.visible.max.version={0} was removed after version {2}: {1}
non.static.aura.method.cannot.have.params=Non static AuraEnabled methods may not have parameters
non.static.aura.method.must.begin.with.get=Non static AuraEnabled methods must be named with a prefix 'get'
aura.duplicate.method.field=AuraEnabled method and variable cannot have the same name: {0}
aura.overloaded.method=Overload of AuraEnabled method: {0} overload is not permitted
abstract.methods.cannot.have.body=Abstract methods cannot have a body
method.must.have.body=Method must have a body
global.deprecate.if.return.deprecated=Global methods must be deprecated when return type is deprecated: {0}
global.deprecate.if.parameter.deprecated=Global methods must be deprecated when parameter type is deprecated: {0}
global.deprecate.if.type.deprecated=Global fields must be deprecated when type is deprecated: {0}
webservice.deprecate.if.type.deprecated=WebService fields must be deprecated when type is deprecated: {0}
test.method.cannot.have.params=Test methods must have no arguments
test.setup.must.return.void=Test setup method must return void
test.setup.cannot.have.params=Test methods must have no arguments
test.setup.cannot.have.defining.type.see.all.data=Test class cannot be annotated with @isTest(SeeAllData=true)
test.setup.cannot.have.see.all.data=Test class containing a test setup method cannot have any methods annotated with @isTest(SeeAllData=true)
parallel.test.class.cannot.have.see.all.data=Test class annotated with @isTest(IsParallel=true) cannot also be annotated with @isTest(SeeAllData=true)
parallel.test.method.cannot.have.see.all.data=Test class annotated with @isTest(IsParallel=true) cannot have any methods annotated with @isTest(SeeAllData=true)
test.class.must.not.be.exception=Only top-level non-exception class types can be marked as tests
invalid.method.with.parameters={0} methods do not support parameters
duplicate.modifier=Duplicate modifier: {0}
field.does.not.support.type={0} fields do not support type of {1}
usereplica.preferred.must.be.static=ReadOnly methods with useReplica=preferred parameter must be declared as static
# rule on an enclosing type, global modifiers require type to be global
enclosing.type.for=Enclosing type for {0} {1} in apex
invalid.multiple.methods.with.modifier=Only one method per type can be defined with: {0}
duplicate.remote.action.methods=Remote Action does not support two remote action methods with the same name and same number of parameters
invalid.public.remote.action=Remote Action method must be global in a global component
duplicate.web.service.methods=Web Service does not support two web service methods with the same name: {0}
# rule in an enclosing type, anonymous classes don't allow virtual classes, they are virtual by default
enclosing.type=In enclosing types of, {0},
# top-level types must be declared public or global
toplevel.must.be.public.or.global=Top-level type must have public or global visibility
invalid.read.only=Only WebService, RemoteAction or Schedulable.execute(SchedulableContext) methods can be marked ReadOnly
annotation.not.supported=Annotation is not valid in your org: {0}
annotation.property.min.version=Annotation property, {0} on {1}, must be in version {2} or higher
annotation.property.max.version=Annotation property, {0} on {1}, must be in version {2} or lower
annotation.property.greater.than.or.equal=Annotation property, {0} on {1}, must be greater than or equal to {2}: {3}
annotation.property.less.than.or.equal=Annotation property, {0} on {1}, must be less than or equal to {2}: {3}
annotation.property.bad.string.value=Annotation property, {0} on {1}, unknown value: {2}
annotation.property.invalid.perm.value=Annotation property, {0} on {1}, value is not valid in your org: {2}
annotation.property.not.supported=No such property, {0}, defined on this annotation: {1}
annotation.property.invalid.type=Annotation property, {0} on {1} is not supported for type {2}
annotation.property.invalid.format=Annotation property, the format of {0} on {1} is invalid, please check if the {0} has the correct formats 
annotation.property.invalid.value=Invalid value for property {0} expected type {1}
annotation.property.invalid.multiple.parameter=Annotation property {0} does not support multiple {1} parameters
annotation.property.testFor.invalid.prefix=Invalid prefix for property {0}. Specify {1} in the format ''prefix:name, ...'' where prefix is {2}. Use commas to separate multiple type names in the same format.
annotation.property.testFor.empty.suffix=Invalid value for property {0}, expected Apex {1} name is missing or empty
annotation.property.value.not.found=Invalid value for property {0} expected Apex {1} {2} not found
annotation.property.sibling.invalid.value=Invalid combination of values for properties {0} and {1} on {2}
annotation.property.missing=Required property is missing: {0}
annotation.property.invalid.api.version=Annotation property, {0} on {1}, invalid version: {2}
annotation.property.is.not.allowed=Annotation property, {0} on {1}, is not allowed on {2}
annotation.property.value.is.not.allowed=Invalid annotation property value, {0}, for property {1} on {2}
annotation.property.type.mismatch=The data type of the value for the {0} annotation property doesn''t match the data type of the ''{1}'' variable. Specify a value with a data type of {2}
annotation.property.not.supported.for.type=The {0} annotation property doesn''t support the {1} data type
annotation.property.cannot.be.empty=Specify a value for the {0} annotation property
rest.resource.url.empty=Rest Resource url cannot be empty
rest.resource.url.too.long=Rest Resource url cannot be longer than 255 characters
rest.resource.url.no.slash=Rest Resource url must begin with a forward slash, '/'
rest.resource.url.invalid.url=Rest Resource url was invalid
rest.resource.url.illegal.wildcard.predecessor=Rest Resource url wildcard, '*', must be preceded by a forward slash, '/'
rest.resource.url.illegal.wildcard.successor=Rest Resource url wildcard, '*', must be followed by a forward slash, '/', or be the last character
annotation.jsonaccess.must.specify.control.parameter=At least one JSON serialization control parameter must be specified
annotation.property.invalid.lightning.web.component.name=Invalid value for property configurationEditor: {0} is not a valid Lightning Web Component name
annotation.property.invalid.static.resource.name=Invalid value for property {0}: We cannot find the icon {1}. Ensure that you uploaded the icon as a static resource

class.plural=classes
interface.plural=interfaces
anonymous.plural=anonymous classes
trigger.plural=triggers
enum.plural=enums
annotation.plural=annotations
field.plural=fields
property.plural=properties
local.plural=locals
parameter.plural=parameters
method.plural=methods
constructor.plural=constructors

invalid.metadata.too.large=Class compilation requires too much metadata. Please consider splitting this class into multiple classes
expression.too.long=Expression is too long, please split this expression into multiple statements
unexpected.error=Unexpected error: {0}
invalid.exception.constructor.already.defined=System exception constructor already defined: {0}

class.must.implement.abstract.method=Class {0} must implement the abstract method: {1}
interface.implementation.missing.method=Class {0} must implement the method: {1}
interface.implementation.method.not.visible={0}: Overriding implementations of global or public interface methods must be global or public: {1}
interface.implementation.method.deprecated=Cannot deprecate an interface implementation method: {0}

illegal.accessor.on.property=Cannot declare {0} accessor on {1} property

invalid.unresolved.annotation=Annotation does not exist: {0}

invocable.method.single.param=Only one parameter is supported on methods with @Invocable annotation
invocable.method.non.list.parameter=Unsupported parameter type {0}. Valid invocable parameters must be List types like List<T> where T is a supported type
invocable.method.can.only.have.deprecated=The only annotation that can be used with InvocableMethod is Deprecated

invalid.instanceof.always.true=Operation instanceof is always true since an instance of {0} is always an instance of {1}
invalid.instanceof.always.false=Operation instanceof is always false since an instance of {0} is never an instance of {1}
invalid.instanceof.invalid.type=Operation instanceof is not allowed on type: {0}

# visibility errors
variable.not.visible=Variable is not visible: {0}
method.not.visible=Method is not visible: {0}
method.return.type.not.visible=Method return type {0} is not visible for: {1}
method.parameter.type.not.visible=Method parameter type {0} is not visible for: {1}
type.not.visible=Type is not visible: {0}

# generics
type.parameters.not.supported=Type parameters are not supported
duplicate.type.parameter=Duplicate type parameter: {0}

# package version
package.version.requires.namespace=Package.Version Requires a namespaced org
package.version.invalid=Package.Version.{0} is not a valid version.

# additional pass validators
export.data.category=Salesforce.com does not currently allow export of components referencing to Data Categories.
explicit.unmanaged=Unmanaged packages cannot explicitly reference this organization's namespace.
package.version.forbidden=Unmanaged packages cannot reference Package.Version.

# custom settings
method.only.list.custom.settings=Method only supports list type Custom Settings: {0}
custom.settings.namespace.not.visible=Custom Setting cannot be referenced outside code from the same namespace.

# custom metadata types
custom.metadata.type.namespace.not.visible=Custom Metadata Type cannot be referenced outside code from the same namespace.

# size limit error
script.too.large=Script too large: {0}...
query.too.large=Query is too large

invalid.trigger.before.undelete=Trigger Usage Before Undelete is not supported
invalid.duplicate.trigger.usage=Duplicate Trigger Usage: {0}

duplicate.type.name=Type name already in use: {0}

dependent.class.invalid=Dependent class is invalid and needs recompilation:\n Class {0} : {1}
dependent.class.invalidChain={0}-->{1}

# lsp errors
new.name.conflict.local=New identifier name cannot be the same as the name of an existing local variable or parameter
new.name.member.conflict=New name cannot be the same as the name of an existing member in: {0}
cannot.rename=Unable to rename symbol. You can rename symbols only if they are defined in a source file
new.name.conflict.inner=New name cannot be the same as the name of an inner type
new.inner.type.name.conflict.outer=New name for inner type cannot be the same as the name of the containing outer type
new.inner.type.name.conflict.super.type=New name for inner type cannot be the same as the type being extended by the outer type
new.inner.type.name.conflict.interface=New name for inner type cannot be the same as the interface being implemented by the outer type
new.name.invalid.exception=New name for an exception type must end in 'Exception'
new.name.cannot.end.exception=New name for a type that is not an Exception cannot end in 'Exception'

# lsp code actions
declare.missing.method=Create method ''{0}'' in ''{1}''
declare.missing.method.available=Quick fix available: Declare missing method, ''{0}''

#lsp strings
extract.constant=Extract Constant
extract.variable=Extract Variable

#deprecated method errors
deprecate.sobject.recalculateformulas=SObject.recalculateFormulas() is deprecated as of API version 57.0. Use Formula.recalculateFormulas() instead

# apex-language-support project-specific error codes
# These error codes are unique to this project and not part of the Salesforce compiler
annotation.unknown=Unknown annotation: {0}