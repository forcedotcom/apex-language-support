name: Release VS Code Extensions

on:
  push:
    branches: [main]
  workflow_call:
    inputs:
      branch:
        description: 'Branch to release from'
        required: false
        default: 'main'
        type: string
      extensions:
        description: 'Extensions to release'
        required: false
        default: 'apex-lsp-vscode-extension'
        type: string
      registry:
        description: 'Registry to publish to'
        required: false
        default: 'all'
        type: string
      available-extensions:
        description: 'Available VS Code extensions'
        required: false
        type: string
      dry-run:
        description: 'Run in dry-run mode (no actual publishing)'
        required: false
        default: 'false'
        type: string
      pre-release:
        description: 'Publish as pre-release version'
        required: false
        default: 'false'
        type: string
      base-branch:
        description: 'Base branch to compare against for change detection'
        required: false
        default: 'main'
        type: string
      version-bump:
        description: 'Version bump type (auto, patch, minor, major)'
        required: false
        default: 'auto'
        type: string
  workflow_dispatch:
    inputs:
      extensions:
        description: 'Extensions to release'
        required: false
        default: 'apex-lsp-vscode-extension'
        type: choice
        options:
          - all
          - apex-lsp-vscode-extension
          - apex-lsp-vscode-extension-web
      registry:
        description: 'Registry to publish to'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - vscode
          - openvsx
      dry-run:
        description: 'Run in dry-run mode (no actual publishing)'
        required: false
        default: 'false'
        type: string
      pre-release:
        description: 'Publish as pre-release version'
        required: false
        default: 'false'
        type: string

jobs:
  determine-build-type:
    runs-on: ubuntu-latest
    outputs:
      is-nightly: ${{ steps.check.outputs.is-nightly }}
      version-bump: ${{ steps.check.outputs.version-bump }}
      pre-release: ${{ steps.check.outputs.pre-release }}
    steps:
      - name: Check build type
        id: check
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "is-nightly=true" >> $GITHUB_OUTPUT
            echo "version-bump=patch" >> $GITHUB_OUTPUT
            echo "pre-release=true" >> $GITHUB_OUTPUT
          else
            echo "is-nightly=false" >> $GITHUB_OUTPUT
            echo "version-bump=${{ inputs.version-bump || 'auto' }}" >> $GITHUB_OUTPUT
            echo "pre-release=${{ inputs.pre-release || 'false' }}" >> $GITHUB_OUTPUT
          fi

  determine-changes:
    needs: determine-build-type
    runs-on: ubuntu-latest
    outputs:
      selected-extensions: ${{ steps.changes.outputs.selected-extensions }}
      version-bumps: ${{ steps.changes.outputs.version-bumps }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine changes and version bumps
        id: changes
        run: |
          # Get build context
          IS_NIGHTLY="${{ needs.determine-build-type.outputs.is-nightly }}"
          VERSION_BUMP="${{ needs.determine-build-type.outputs.version-bump }}"
          PRE_RELEASE="${{ needs.determine-build-type.outputs.pre-release }}"

          echo "Build context:"
          echo "  Is nightly: $IS_NIGHTLY"
          echo "  Version bump: $VERSION_BUMP"
          echo "  Pre-release: $PRE_RELEASE"

          # For nightly builds, always use patch bump and ensure pre-release
          if [ "$IS_NIGHTLY" = "true" ]; then
            echo "Nightly build detected - using patch bump strategy"
            VERSION_BUMP="patch"
            PRE_RELEASE="true"
          fi

          # Determine which extensions have changes
          EXTENSIONS_WITH_CHANGES=""
          VERSION_BUMP_TYPES=""

          # Check each extension for changes
          for ext in apex-lsp-vscode-extension apex-lsp-vscode-extension-web; do
            if [ -d "packages/$ext" ]; then
              # For nightly builds, always include extensions
              if [ "$IS_NIGHTLY" = "true" ]; then
                if [ -z "$EXTENSIONS_WITH_CHANGES" ]; then
                  EXTENSIONS_WITH_CHANGES="$ext"
                else
                  EXTENSIONS_WITH_CHANGES="$EXTENSIONS_WITH_CHANGES,$ext"
                fi
                VERSION_BUMP_TYPES="$VERSION_BUMP"
              else
                # Check for actual changes
                BASE_BRANCH="${{ inputs.base-branch || 'main' }}"
                
                # Check if the base branch exists, fall back to main if it doesn't
                if ! git ls-remote --heads origin "$BASE_BRANCH" | grep -q "$BASE_BRANCH"; then
                  echo "Warning: Base branch 'origin/$BASE_BRANCH' does not exist, falling back to 'main'"
                  BASE_BRANCH="main"
                fi
                
                CHANGES=$(git diff --name-only origin/$BASE_BRANCH..HEAD -- "packages/$ext/")
                if [ -n "$CHANGES" ]; then
                  if [ -z "$EXTENSIONS_WITH_CHANGES" ]; then
                    EXTENSIONS_WITH_CHANGES="$ext"
                  else
                    EXTENSIONS_WITH_CHANGES="$EXTENSIONS_WITH_CHANGES,$ext"
                  fi
                  VERSION_BUMP_TYPES="$VERSION_BUMP"
                fi
              fi
            fi
          done

          echo "Selected extensions: $EXTENSIONS_WITH_CHANGES"
          echo "Version bump types: $VERSION_BUMP_TYPES"

          echo "selected-extensions=$EXTENSIONS_WITH_CHANGES" >> $GITHUB_OUTPUT
          echo "version-bumps=$VERSION_BUMP_TYPES" >> $GITHUB_OUTPUT

  display-release-plan:
    needs: [determine-build-type, determine-changes]
    runs-on: ubuntu-latest
    if: (inputs.dry-run == 'true' || github.event.inputs.dry-run == 'true') && needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm ci

      - name: Display Extension Release Plan
        run: |
          # Get build context variables
          IS_NIGHTLY="${{ needs.determine-build-type.outputs.is-nightly }}"
          VERSION_BUMP="${{ needs.determine-build-type.outputs.version-bump }}"
          PRE_RELEASE="${{ needs.determine-build-type.outputs.pre-release }}"

          echo "=== EXTENSION RELEASE PLAN ==="
          echo "Branch: ${{ inputs.branch || github.ref_name }}"
          echo "Build type: ${{ github.event_name }}"
          echo "Is nightly: $IS_NIGHTLY"
          echo "Version bump type: $VERSION_BUMP"
          echo "Registry: ${{ inputs.registry }}"
          echo "Pre-release: $PRE_RELEASE"
          echo "Dry run mode: ENABLED"
          echo ""

          # Determine which extensions to release
          EXTENSIONS_TO_RELEASE="${{ needs.determine-changes.outputs.selected-extensions }}"
          echo "Extensions to release: $EXTENSIONS_TO_RELEASE"
          echo ""

          # Show what would happen for each extension
          IFS=',' read -ra EXT_ARRAY <<< "$EXTENSIONS_TO_RELEASE"
          for ext in "${EXT_ARRAY[@]}"; do
            if [ -n "$ext" ] && [ -d "packages/$ext" ]; then
              echo "Extension: $ext"
              
              # Get current version and publisher
              CURRENT_VERSION=$(node -p "require('./packages/$ext/package.json').version")
              PUBLISHER=$(node -p "require('./packages/$ext/package.json').publisher")
              echo "  Current version: $CURRENT_VERSION"
              echo "  Publisher: $PUBLISHER"
              
              # Calculate new version
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              MAJOR="${VERSION_PARTS[0]}"
              MINOR="${VERSION_PARTS[1]}"
              PATCH="${VERSION_PARTS[2]}"
              
              # Use VERSION_BUMP from determine-build-type job
              case "$VERSION_BUMP" in
                "major")
                  NEW_VERSION="$((MAJOR + 1)).0.0"
                  ;;
                "minor")
                  NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                  ;;
                "patch")
                  NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                  ;;
                "auto")
                  # For auto, default to patch
                  NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                  ;;
                *)
                  # Default to patch if unknown
                  NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                  ;;
              esac
              
              # Show version bump information
              echo "  Would bump to: $NEW_VERSION"
              if [ "$IS_NIGHTLY" = "true" ]; then
                echo "  Version strategy: Nightly build (odd minor + nightly timestamp)"
              else
                echo "  Version strategy: $VERSION_BUMP (conventional commit) + VS Code even/odd (pre-release: $PRE_RELEASE)"
              fi
              
              # Show release information
              PRE_RELEASE_TEXT=""
              if [ "${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}" = "true" ]; then
                PRE_RELEASE_TEXT=" (pre-release)"
              fi
              echo "  Would create GitHub release: $ext$PRE_RELEASE_TEXT"
              
              # Show marketplace publishing information
              IFS=',' read -ra REG_ARRAY <<< "${{ inputs.registry }}"
              for registry in "${REG_ARRAY[@]}"; do
                case "$registry" in
                  "vscode"|"all")
                    if [ "$ext" = "apex-lsp-vscode-extension" ]; then
                      echo "  Would publish to: VSCode Marketplace$PRE_RELEASE_TEXT"
                    fi
                    ;;
                  "openvsx"|"all")
                    if [ "$ext" = "apex-lsp-vscode-extension-web" ]; then
                      echo "  Would publish to: OpenVSX Registry$PRE_RELEASE_TEXT"
                    fi
                    ;;
                esac
              done
            fi
          done

          echo "✅ Extension release dry run completed"

  package:
    needs: determine-changes
    if: inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true'
    uses: ./.github/workflows/package.yml
    with:
      branch: ${{ inputs.branch || github.ref_name }}
      artifact-name: vsix-packages

  create-github-releases:
    needs: [determine-changes, package, bump-versions]
    runs-on: ubuntu-latest
    if: (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true') && needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download VSIX artifacts
        uses: actions/download-artifact@v4
        with:
          name: vsix-packages
          path: ./vsix-artifacts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Create GitHub Releases
        run: |
          # Get pre-release flag
          PRE_RELEASE="${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}"
          VERSION_BUMP="${{ needs.determine-changes.outputs.version-bumps }}"
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"

          echo "Creating GitHub releases..."
          echo "Pre-release: $PRE_RELEASE"
          echo "Version bump: $VERSION_BUMP"
          echo "Extensions: $SELECTED_EXTENSIONS"

          # Convert comma-separated list to array
          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"

          for ext in "${EXTENSIONS[@]}"; do
            if [ -n "$ext" ] && [ -d "packages/$ext" ]; then
              echo "Processing extension: $ext"
              
              # Get current version
              CURRENT_VERSION=$(node -p "require('./packages/$ext/package.json').version")
              echo "Current version: $CURRENT_VERSION"
              
              # Find VSIX file for this extension
              VSIX_PATTERN="*${ext}*.vsix"
              VSIX_FILES=$(find ./vsix-artifacts -name "$VSIX_PATTERN")
              
              if [ -z "$VSIX_FILES" ]; then
                echo "No VSIX files found for $ext"
                continue
              fi
              
              # Create release tag
              RELEASE_TAG="v$CURRENT_VERSION"
              RELEASE_TITLE="$ext v$CURRENT_VERSION"
              
              # For nightly builds, add timestamp to tag and title
              if [ "$IS_NIGHTLY" = "true" ]; then
                NIGHTLY_DATE=$(date +%Y%m%d)
                RELEASE_TAG="v$CURRENT_VERSION-nightly.$NIGHTLY_DATE"
                RELEASE_TITLE="$ext v$CURRENT_VERSION (Nightly $NIGHTLY_DATE)"
              fi
              
              # Generate release notes
              RELEASE_NOTES="## $ext v$CURRENT_VERSION\n\n"
              RELEASE_NOTES+="### Changes\n\n"
              
              # Get recent commits for this extension
              RECENT_COMMITS=$(git log --oneline HEAD~10..HEAD -- "packages/$ext/")
              if [ -n "$RECENT_COMMITS" ]; then
                echo "$RECENT_COMMITS" | while read -r commit; do
                  RELEASE_NOTES+="- $commit\n"
                done
              else
                RELEASE_NOTES+="- General improvements and bug fixes\n"
              fi
              
              RELEASE_NOTES+="\n### Installation\n\n"
              RELEASE_NOTES+="Download the VSIX file and install via:\n"
              RELEASE_NOTES+="- VS Code: Install from VSIX...\n"
              RELEASE_NOTES+="- Command line: \`code --install-extension <vsix-file>\`\n"
              
              if [ "$PRE_RELEASE" = "true" ]; then
                RELEASE_NOTES+="\n⚠️ **This is a pre-release version**\n"
              fi
              
              if [ "$IS_NIGHTLY" = "true" ]; then
                RELEASE_NOTES+="\n🌙 **This is a nightly build from $NIGHTLY_DATE**\n"
                RELEASE_NOTES+="\n### Nightly Build Information\n"
                RELEASE_NOTES+="- **Build Date**: $NIGHTLY_DATE\n"
                RELEASE_NOTES+="- **Version**: $CURRENT_VERSION (odd minor for pre-release)\n"
                RELEASE_NOTES+="- **Type**: Nightly pre-release for testing\n"
              fi
              
              # Create GitHub release
              echo "Creating release: $RELEASE_TITLE"
              echo "Tag: $RELEASE_TAG"
              echo "Pre-release: $PRE_RELEASE"
              
              # Create release using GitHub CLI
              gh release create "$RELEASE_TAG" \
                --title "$RELEASE_TITLE" \
                --notes "$RELEASE_NOTES" \
                --prerelease="$PRE_RELEASE" \
                --repo "$GITHUB_REPOSITORY" \
                $VSIX_FILES || echo "Release creation failed or already exists"
              
              echo "✅ Release created for $ext"
            fi
          done

  publish-vscode:
    needs: [bump-versions, package, create-github-releases]
    if: (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true') && (inputs.registry == 'all' || inputs.registry == 'vscode')
    uses: ./.github/workflows/publishVSCode.yml
    with:
      branch: ${{ inputs.branch || github.ref_name }}
      pre-release: ${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}
    secrets: inherit

  publish-openvsx:
    needs: [bump-versions, package, create-github-releases]
    if: (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true') && (inputs.registry == 'all' || inputs.registry == 'openvsx')
    uses: ./.github/workflows/publishOpenVSX.yml
    with:
      branch: ${{ inputs.branch || github.ref_name }}
      pre-release: ${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}
    secrets: inherit

  bump-versions:
    needs: [determine-changes, package]
    runs-on: ubuntu-latest
    if: (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true') && needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        run: npm ci

      - name: Bump versions for selected extensions
        run: |
          VERSION_BUMP="${{ needs.determine-changes.outputs.version-bumps }}"
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"
          PRE_RELEASE="${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}"
          IS_NIGHTLY="${{ needs.determine-build-type.outputs.is-nightly }}"

          echo "Version bump type: $VERSION_BUMP"
          echo "Selected extensions: $SELECTED_EXTENSIONS"
          echo "Pre-release mode: $PRE_RELEASE"
          echo "Is nightly build: $IS_NIGHTLY"

          # Convert comma-separated list to array
          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"

          for pkg in "${EXTENSIONS[@]}"; do
            if [ -n "$pkg" ] && [ -f "packages/$pkg/package.json" ]; then
              echo "Bumping version for $pkg..."
              
              # Get current version
              CURRENT_VERSION=$(node -p "require('./packages/$pkg/package.json').version")
              echo "Current version: $CURRENT_VERSION"
              
              # Parse current version components
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              CURRENT_MAJOR="${VERSION_PARTS[0]}"
              CURRENT_MINOR="${VERSION_PARTS[1]}"
              CURRENT_PATCH="${VERSION_PARTS[2]}"
              
              # Determine target version based on build type and pre-release status
              TARGET_MAJOR="$CURRENT_MAJOR"
              TARGET_MINOR="$CURRENT_MINOR"
              TARGET_PATCH="$CURRENT_PATCH"
              
              if [ "$IS_NIGHTLY" = "true" ]; then
                # Nightly build strategy: ensure odd minor version and add nightly timestamp
                echo "Applying nightly build version strategy..."
                
                # For nightly builds, we want to ensure odd minor version
                if [ $((CURRENT_MINOR % 2)) -eq 0 ]; then
                  # Current is even, bump to next odd
                  TARGET_MINOR=$((CURRENT_MINOR + 1))
                  TARGET_PATCH=0
                else
                  # Current is already odd, just increment patch
                  TARGET_PATCH=$((CURRENT_PATCH + 1))
                fi
                
                # Use proper major.minor.patch version for package.json
                NEW_VERSION="$TARGET_MAJOR.$TARGET_MINOR.$TARGET_PATCH"
                echo "Nightly version: $NEW_VERSION (odd minor: $TARGET_MINOR)"
                echo "Note: Nightly timestamp will be added as release tag/metadata"
              else
                # Regular build strategy: use smart version bumping
                case "$VERSION_BUMP" in
                  "patch")
                    # For patch bumps, just increment patch
                    TARGET_PATCH=$((CURRENT_PATCH + 1))
                    ;;
                  "minor")
                    # For minor bumps, we need to be smart about even/odd
                    if [ "$PRE_RELEASE" = "true" ]; then
                      # Pre-release: ensure odd minor version
                      if [ $((CURRENT_MINOR % 2)) -eq 0 ]; then
                        # Current is even, bump to next odd
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      else
                        # Current is already odd, just increment
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      fi
                    else
                      # Stable release: ensure even minor version
                      if [ $((CURRENT_MINOR % 2)) -eq 1 ]; then
                        # Current is odd, bump to next even
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      else
                        # Current is already even, just increment
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      fi
                    fi
                    TARGET_PATCH=0
                    ;;
                  "major")
                    # For major bumps, reset minor and patch
                    TARGET_MAJOR=$((CURRENT_MAJOR + 1))
                    if [ "$PRE_RELEASE" = "true" ]; then
                      # Pre-release: start with odd minor
                      TARGET_MINOR=1
                    else
                      # Stable release: start with even minor
                      TARGET_MINOR=0
                    fi
                    TARGET_PATCH=0
                    ;;
                esac
                
                # Construct new version
                NEW_VERSION="$TARGET_MAJOR.$TARGET_MINOR.$TARGET_PATCH"
                echo "Regular version: $NEW_VERSION (bump: $VERSION_BUMP, pre-release: $PRE_RELEASE)"
              fi
              
              # Update package.json version
              cd packages/$pkg
              npm version "$NEW_VERSION" --no-git-tag-version
              cd ../..
              
              # Update package-lock.json if it exists
              if [ -f "package-lock.json" ]; then
                npm install
              fi
            fi
          done

      - name: Commit version bumps
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "chore: bump versions for release [skip ci]" || echo "No changes to commit"
          git push
