name: Release VS Code Extensions

on:
  workflow_call:
    inputs:
      branch:
        description: 'Branch to release from'
        required: false
        default: 'main'
        type: string
      extensions:
        description: 'Extensions to release'
        required: false
        default: 'apex-lsp-vscode-extension'
        type: string
      registries:
        description: 'Registries to publish to (all, vsce, ovsx)'
        required: false
        default: 'all'
        type: string
      available-extensions:
        description: 'Available VS Code extensions'
        required: false
        type: string
      dry-run:
        description: 'Run in dry-run mode (no actual publishing)'
        required: false
        default: 'false'
        type: string
      pre-release:
        description: 'Publish as pre-release version'
        required: false
        default: 'false'
        type: string

      version-bump:
        description: 'Version bump type (auto, patch, minor, major)'
        required: false
        default: 'auto'
        type: string
  workflow_dispatch:
    inputs:
      extensions:
        description: 'Extensions to release'
        required: false
        default: 'apex-lsp-vscode-extension'
        type: choice
        options:
          - all
          - apex-lsp-vscode-extension
          - apex-lsp-vscode-extension-web
      registries:
        description: 'Registries to publish to'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - vsce
          - ovsx
      dry-run:
        description: 'Run in dry-run mode (no actual publishing)'
        required: false
        default: 'false'
        type: string
      pre-release:
        description: 'Publish as pre-release version'
        required: false
        default: 'false'
        type: string

# Add explicit permissions for security
permissions:
  contents: write # Needed for version bumps and releases
  packages: write # Needed for publishing to registries
  actions: read

jobs:
  determine-build-type:
    runs-on: ubuntu-latest
    outputs:
      is-nightly: ${{ steps.check.outputs.is-nightly }}
      version-bump: ${{ steps.check.outputs.version-bump }}
      pre-release: ${{ steps.check.outputs.pre-release }}
      is-promotion: ${{ steps.check.outputs.is-promotion }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Check build type
        id: check
        run: |
          npx tsx .github/scripts/index.ts ext-build-type \
            --event-name "${{ github.event_name }}" \
            --version-bump "${{ inputs.version-bump || 'auto' }}" \
            --pre-release "${{ inputs.pre-release || 'false' }}"

  find-promotion-candidate:
    needs: determine-build-type
    runs-on: ubuntu-latest
    if: needs.determine-build-type.outputs.is-promotion == 'true'
    outputs:
      promotion-commit-sha: ${{ steps.find.outputs.commit-sha }}
      promotion-nightly-tag: ${{ steps.find.outputs.nightly-tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Find nightly build to promote
        id: find
        run: |
          npx tsx .github/scripts/index.ts ext-promotion-finder

  determine-changes:
    needs: [determine-build-type, find-promotion-candidate]
    runs-on: ubuntu-latest
    outputs:
      selected-extensions: ${{ steps.changes.outputs.selected-extensions }}
      version-bumps: ${{ steps.changes.outputs.version-bumps }}
      promotion-commit-sha: ${{ steps.changes.outputs.promotion-commit-sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Determine changes and version bumps
        id: changes
        run: |
          npx tsx .github/scripts/index.ts ext-change-detector \
            --is-nightly "${{ needs.determine-build-type.outputs.is-nightly }}" \
            --version-bump "${{ needs.determine-build-type.outputs.version-bump }}" \
            --pre-release "${{ needs.determine-build-type.outputs.pre-release }}" \
            --is-promotion "${{ needs.determine-build-type.outputs.is-promotion }}" \
            --promotion-commit-sha "${{ needs.find-promotion-candidate.outputs.promotion-commit-sha }}"

  display-release-plan:
    needs: [determine-build-type, determine-changes]
    runs-on: ubuntu-latest
    if: (inputs.dry-run == 'true' || github.event.inputs.dry-run == 'true') && needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Display Extension Release Plan
        run: |
          npx tsx .github/scripts/index.ts ext-release-plan \
            --branch "${{ inputs.branch || github.ref_name }}" \
            --build-type "${{ github.event_name }}" \
            --is-nightly "${{ needs.determine-build-type.outputs.is-nightly }}" \
            --version-bump "${{ needs.determine-build-type.outputs.version-bump }}" \
            --registries "${{ inputs.registries }}" \
            --pre-release "${{ needs.determine-build-type.outputs.pre-release }}" \
            --selected-extensions "${{ needs.determine-changes.outputs.selected-extensions }}"

  bump-versions:
    needs: [determine-changes]
    runs-on: ubuntu-latest
    if: needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Bump versions for selected extensions
        # TODO: Migrate to Node.js script: npx tsx .github/scripts/index.ts ext-version-bumper
        run: |
          DRY_RUN="${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}"
          VERSION_BUMP="${{ needs.determine-changes.outputs.version-bumps }}"
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"
          PRE_RELEASE="${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}"
          IS_NIGHTLY="${{ needs.determine-build-type.outputs.is-nightly }}"
          IS_PROMOTION="${{ needs.determine-build-type.outputs.is-promotion }}"
          PROMOTION_COMMIT_SHA="${{ needs.determine-changes.outputs.promotion-commit-sha }}"

          echo "Mode: $([ "$DRY_RUN" = "true" ] && echo "DRY RUN" || echo "LIVE")"
          echo "Version bump type: $VERSION_BUMP"
          echo "Selected extensions: $SELECTED_EXTENSIONS"
          echo "Pre-release mode: $PRE_RELEASE"
          echo "Is nightly build: $IS_NIGHTLY"
          echo "Is promotion: $IS_PROMOTION"
          echo "Promotion commit SHA: $PROMOTION_COMMIT_SHA"

          # Convert comma-separated list to array
          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"

          for pkg in "${EXTENSIONS[@]}"; do
            if [ -n "$pkg" ] && [ -f "packages/$pkg/package.json" ]; then
              echo "Processing $pkg..."
              
              # Get current version
              CURRENT_VERSION=$(node -p "require('./packages/$pkg/package.json').version")
              echo "Current version: $CURRENT_VERSION"
              
              # Parse current version components
              IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
              CURRENT_MAJOR="${VERSION_PARTS[0]}"
              CURRENT_MINOR="${VERSION_PARTS[1]}"
              CURRENT_PATCH="${VERSION_PARTS[2]}"
              
              # Determine target version based on build type and pre-release status
              TARGET_MAJOR="$CURRENT_MAJOR"
              TARGET_MINOR="$CURRENT_MINOR"
              TARGET_PATCH="$CURRENT_PATCH"
              
              if [ "$IS_NIGHTLY" = "true" ]; then
                # Nightly build strategy: ensure odd minor version and add nightly timestamp
                echo "Applying nightly build version strategy..."
                
                # For nightly builds, we want to ensure odd minor version
                if [ $((CURRENT_MINOR % 2)) -eq 0 ]; then
                  # Current is even, bump to next odd
                  TARGET_MINOR=$((CURRENT_MINOR + 1))
                  TARGET_PATCH=0
                else
                  # Current is already odd, just increment patch
                  TARGET_PATCH=$((CURRENT_PATCH + 1))
                fi
                
                # Use proper major.minor.patch version for package.json
                NEW_VERSION="$TARGET_MAJOR.$TARGET_MINOR.$TARGET_PATCH"
                echo "Nightly version: $NEW_VERSION (odd minor: $TARGET_MINOR)"
                echo "Note: Nightly timestamp will be added as release tag/metadata"
              elif [ "$IS_PROMOTION" = "true" ]; then
                # Promotion strategy: bump from odd minor (nightly) to even minor (stable)
                echo "Applying promotion version strategy..."
                
                # For promotions, we always bump from odd minor to even minor
                if [ $((CURRENT_MINOR % 2)) -eq 1 ]; then
                  # Current is odd (nightly), bump to next even (stable)
                  TARGET_MINOR=$((CURRENT_MINOR + 1))
                  TARGET_PATCH=0
                else
                  # Current is already even, this shouldn't happen for promotions
                  echo "Warning: Current version has even minor, expected odd for promotion"
                  TARGET_MINOR=$((CURRENT_MINOR + 2))
                  TARGET_PATCH=0
                fi
                
                # Use proper major.minor.patch version for package.json
                NEW_VERSION="$TARGET_MAJOR.$TARGET_MINOR.$TARGET_PATCH"
                echo "Promotion version: $NEW_VERSION (even minor: $TARGET_MINOR)"
              else
                # Regular build strategy: use smart version bumping
                case "$VERSION_BUMP" in
                  "patch")
                    # For patch bumps, just increment patch
                    TARGET_PATCH=$((CURRENT_PATCH + 1))
                    ;;
                  "minor")
                    # For minor bumps, we need to be smart about even/odd
                    if [ "$PRE_RELEASE" = "true" ]; then
                      # Pre-release: ensure odd minor version (no auto-update)
                      if [ $((CURRENT_MINOR % 2)) -eq 0 ]; then
                        # Current is even, bump to next odd
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      else
                        # Current is already odd, jump to next odd
                        TARGET_MINOR=$((CURRENT_MINOR + 2))
                      fi
                    else
                      # Stable release: ensure even minor version (auto-update enabled)
                      if [ $((CURRENT_MINOR % 2)) -eq 1 ]; then
                        # Current is odd, bump to next even
                        TARGET_MINOR=$((CURRENT_MINOR + 1))
                      else
                        # Current is already even, jump to next even
                        TARGET_MINOR=$((CURRENT_MINOR + 2))
                      fi
                    fi
                    TARGET_PATCH=0
                    ;;
                  "major")
                    # For major bumps, reset minor and patch
                    TARGET_MAJOR=$((CURRENT_MAJOR + 1))
                    if [ "$PRE_RELEASE" = "true" ]; then
                      # Pre-release: start with odd minor
                      TARGET_MINOR=1
                    else
                      # Stable release: start with even minor
                      TARGET_MINOR=0
                    fi
                    TARGET_PATCH=0
                    ;;
                esac
                
                # Construct new version
                NEW_VERSION="$TARGET_MAJOR.$TARGET_MINOR.$TARGET_PATCH"
                echo "Regular version: $NEW_VERSION (bump: $VERSION_BUMP, pre-release: $PRE_RELEASE)"
              fi
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "‚úÖ DRY RUN: Would bump $pkg from $CURRENT_VERSION to $NEW_VERSION"
              else
                echo "üîÑ LIVE: Bumping $pkg from $CURRENT_VERSION to $NEW_VERSION"
                # Update package.json version
                cd packages/$pkg
                npm version "$NEW_VERSION" --no-git-tag-version
                cd ../..
                
                # Note: package-lock.json is intentionally not updated here
                # The lock file should already be up-to-date and version bumps
                # don't affect dependency resolution
              fi
            fi
          done

          if [ "$DRY_RUN" = "true" ]; then
            echo "‚úÖ DRY RUN: Version bump simulation completed"
          else
            echo "‚úÖ LIVE: Version bumps applied"
          fi

      - name: Validate GitHub authentication
        if: inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true'
        run: |
          # Validate that required tokens are present
          if [ -z "$GITHUB_TOKEN" ]; then
            echo "‚ùå Error: GITHUB_TOKEN is not set"
            exit 1
          fi

          # Test GitHub CLI authentication
          if ! gh auth status >/dev/null 2>&1; then
            echo "‚ùå Error: GitHub CLI authentication failed"
            exit 1
          fi

          echo "‚úÖ GitHub authentication validated"

      - name: Commit version bumps
        if: inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true'
        env:
          # Ensure GitHub CLI has proper authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IS_PROMOTION="${{ needs.determine-build-type.outputs.is-promotion }}"
          PROMOTION_COMMIT_SHA="${{ needs.determine-changes.outputs.promotion-commit-sha }}"

          if [ "$IS_PROMOTION" = "true" ] && [ -n "$PROMOTION_COMMIT_SHA" ]; then
            echo "üîÑ PROMOTION: Creating release tag on promotion commit..."
            
            # Get the new version from package.json
            NEW_VERSION=$(node -p "require('./packages/apex-lsp-vscode-extension/package.json').version")
            RELEASE_TAG="v$NEW_VERSION"
            
            echo "Creating release tag: $RELEASE_TAG on commit: $PROMOTION_COMMIT_SHA"
            
            # Create tag on the promotion commit
            git tag "$RELEASE_TAG" "$PROMOTION_COMMIT_SHA"
            git push origin "$RELEASE_TAG"
            
            echo "‚úÖ Release tag created on promotion commit"
          else
            echo "üîÑ REGULAR: Committing version bumps to HEAD..."
            
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add .
            git commit -m "chore: bump versions for release [skip ci]"

            # Push version bumps - fail if branch protection blocks it
            echo "Pushing version bumps to ${{ inputs.branch || github.ref_name }}..."
            if ! git push origin HEAD:${{ inputs.branch || github.ref_name }}; then
              echo "‚ùå Error: Direct push failed. This may be due to branch protection rules."
              echo "The workflow requires direct push access to ${{ inputs.branch || github.ref_name }}"
              echo "Please ensure the workflow has proper permissions or run manually."
              exit 1
            fi

            echo "‚úÖ Version bumps pushed successfully"
          fi

  calculate-artifact-name:
    runs-on: ubuntu-latest
    outputs:
      artifact-name: ${{ steps.calc.outputs.artifact-name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate artifact name
        id: calc
        uses: ./.github/actions/calculate-artifact-name
        with:
          artifact-name: vsix-packages
          dry-run: ${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}

  package:
    needs: [bump-versions, calculate-artifact-name, determine-changes]
    uses: ./.github/workflows/package.yml
    with:
      branch: ${{ inputs.branch || github.ref_name }}
      artifact-name: ${{ needs.calculate-artifact-name.outputs.artifact-name }}
      dry-run: ${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}

  create-github-releases:
    needs: [determine-changes, package, bump-versions, calculate-artifact-name]
    runs-on: ubuntu-latest
    if: needs.determine-changes.outputs.selected-extensions != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ inputs.branch || github.ref }}

      - name: Download VSIX artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.calculate-artifact-name.outputs.artifact-name }}
          path: ./vsix-artifacts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Validate GitHub authentication
        if: inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true'
        run: |
          # Validate that required tokens are present
          if [ -z "$GITHUB_TOKEN" ]; then
            echo "‚ùå Error: GITHUB_TOKEN is not set"
            exit 1
          fi

          # Test GitHub CLI authentication
          if ! gh auth status >/dev/null 2>&1; then
            echo "‚ùå Error: GitHub CLI authentication failed"
            exit 1
          fi

          echo "‚úÖ GitHub authentication validated"

      - name: Create GitHub Releases
        env:
          # Ensure GitHub CLI has proper authentication
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DRY_RUN="${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}"
          PRE_RELEASE="${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}"
          VERSION_BUMP="${{ needs.determine-changes.outputs.version-bumps }}"
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"
          IS_NIGHTLY="${{ needs.determine-build-type.outputs.is-nightly }}"

          echo "Mode: $([ "$DRY_RUN" = "true" ] && echo "DRY RUN" || echo "LIVE")"
          echo "Creating GitHub releases..."
          echo "Pre-release: $PRE_RELEASE"
          echo "Version bump: $VERSION_BUMP"
          echo "Extensions: $SELECTED_EXTENSIONS"

          # Convert comma-separated list to array
          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"

          for ext in "${EXTENSIONS[@]}"; do
            if [ -n "$ext" ] && [ -d "packages/$ext" ]; then
              echo "Processing extension: $ext"
              
              # Get current version
              CURRENT_VERSION=$(node -p "require('./packages/$ext/package.json').version")
              echo "Current version: $CURRENT_VERSION"
              
              # Find VSIX file for this extension
              VSIX_PATTERN="*${ext}*.vsix"
              VSIX_FILES=$(find "./vsix-artifacts" -name "$VSIX_PATTERN")
              
              if [ -z "$VSIX_FILES" ]; then
                echo "No VSIX files found for $ext in ./vsix-artifacts"
                continue
              fi
              
              # Create release tag
              RELEASE_TAG="v$CURRENT_VERSION"
              RELEASE_TITLE="$ext v$CURRENT_VERSION"
              
              # For nightly builds, add timestamp to tag and title
              if [ "$IS_NIGHTLY" = "true" ]; then
                NIGHTLY_DATE=$(date +%Y%m%d)
                RELEASE_TAG="v$CURRENT_VERSION-nightly.$NIGHTLY_DATE"
                RELEASE_TITLE="$ext v$CURRENT_VERSION (Nightly $NIGHTLY_DATE)"
              fi
              
              # Generate release notes
              RELEASE_NOTES="## $ext v$CURRENT_VERSION\n\n"
              RELEASE_NOTES+="### Changes\n\n"
              
              # Find the last release tag for this extension to get commits since last release
              LAST_TAG=""
              ALL_TAGS=$(git tag --sort=-version:refname | grep "^v")
              if [ -n "$ALL_TAGS" ]; then
                LAST_TAG=$(echo "$ALL_TAGS" | head -1)
              fi
              
              if [ -n "$LAST_TAG" ]; then
                # Get commits since the last release
                RECENT_COMMITS=$(git log --oneline "$LAST_TAG"..HEAD -- "packages/$ext/")
                if [ -n "$RECENT_COMMITS" ]; then
                  echo "$RECENT_COMMITS" | while read -r commit; do
                    RELEASE_NOTES+="- $commit\n"
                  done
                else
                  RELEASE_NOTES+="- General improvements and bug fixes\n"
                fi
              else
                # First release - get all commits for this extension
                RECENT_COMMITS=$(git log --oneline -- "packages/$ext/")
                if [ -n "$RECENT_COMMITS" ]; then
                  echo "$RECENT_COMMITS" | while read -r commit; do
                    RELEASE_NOTES+="- $commit\n"
                  done
                else
                  RELEASE_NOTES+="- Initial release\n"
                fi
              fi
              
              RELEASE_NOTES+="\n### Installation\n\n"
              RELEASE_NOTES+="Download the VSIX file and install via:\n"
              RELEASE_NOTES+="- VS Code: Install from VSIX...\n"
              RELEASE_NOTES+="- Command line: \`code --install-extension <vsix-file>\`\n"
              
              if [ "$PRE_RELEASE" = "true" ]; then
                RELEASE_NOTES+="\n‚ö†Ô∏è **This is a pre-release version**\n"
              fi
              
              if [ "$IS_NIGHTLY" = "true" ]; then
                RELEASE_NOTES+="\nüåô **This is a nightly build from $NIGHTLY_DATE**\n"
                RELEASE_NOTES+="\n### Nightly Build Information\n"
                RELEASE_NOTES+="- **Build Date**: $NIGHTLY_DATE\n"
                RELEASE_NOTES+="- **Version**: $CURRENT_VERSION (odd minor for pre-release)\n"
                RELEASE_NOTES+="- **Type**: Nightly pre-release for testing\n"
              fi
              
              if [ "$DRY_RUN" = "true" ]; then
                echo "‚úÖ DRY RUN: Would create GitHub release:"
                echo "  - Tag: $RELEASE_TAG"
                echo "  - Title: $RELEASE_TITLE"
                echo "  - Pre-release: $PRE_RELEASE"
                echo "  - VSIX files: $VSIX_FILES"
                echo "  - Release notes preview:"
                echo "$RELEASE_NOTES" | head -20
                echo "  ... (truncated)"
              else
                echo "üîÑ LIVE: Creating GitHub release..."
                echo "Creating release: $RELEASE_TITLE"
                echo "Tag: $RELEASE_TAG"
                echo "Pre-release: $PRE_RELEASE"
                
                # Create release using GitHub CLI with proper authentication
                gh release create "$RELEASE_TAG" \
                  --title "$RELEASE_TITLE" \
                  --notes "$RELEASE_NOTES" \
                  --prerelease="$PRE_RELEASE" \
                  --repo "$GITHUB_REPOSITORY" \
                  $VSIX_FILES
                
                echo "‚úÖ Release created for $ext"
              fi
            fi
          done

          if [ "$DRY_RUN" = "true" ]; then
            echo "‚úÖ DRY RUN: GitHub release simulation completed"
          else
            echo "‚úÖ LIVE: GitHub releases created"
          fi

  determine-publish-matrix:
    needs: [determine-changes, calculate-artifact-name]
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Install dependencies
        uses: ./.github/actions/npm-install-with-retries

      - name: Determine publish matrix
        id: matrix
        # TODO: Migrate to Node.js script: npx tsx .github/scripts/index.ts ext-publish-matrix
        run: |
          REGISTRIES="${{ inputs.registries }}"
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"

          # Initialize empty JSON array
          MATRIX_ENTRIES='[]'

          # Determine which registries to include
          REGISTRY_LIST=""
          if [ "$REGISTRIES" = "all" ]; then
            REGISTRY_LIST="vsce ovsx"
          else
            REGISTRY_LIST="$REGISTRIES"
          fi

          # Create matrix entries for each extension-registry combination
          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"
          for ext in "${EXTENSIONS[@]}"; do
            if [ -n "$ext" ]; then
              # Create VSIX pattern for this extension
              # Map extension names to their actual VSIX file patterns
              case "$ext" in
                "apex-lsp-vscode-extension")
                  VSIX_PATTERN="*apex-language-server-extension*.vsix"
                  ;;
                "apex-lsp-vscode-extension-web")
                  VSIX_PATTERN="*apex-language-server-extension-web*.vsix"
                  ;;
                *)
                  # Fallback to original pattern
                  VSIX_PATTERN="*${ext}*.vsix"
                  ;;
              esac
              
              # Add entry for each selected registry
              for registry in $REGISTRY_LIST; do
                case "$registry" in
                  "vsce")
                    MARKETPLACE="VS Code Marketplace"
                    ;;
                  "ovsx")
                    MARKETPLACE="Open VSX Registry"
                    ;;
                  *)
                    MARKETPLACE="$registry"
                    ;;
                esac
                
                # Create JSON entry and add to matrix
                ENTRY=$(jq -n \
                  --arg registry "$registry" \
                  --arg vsix_pattern "$VSIX_PATTERN" \
                  --arg marketplace "$MARKETPLACE" \
                  '{registry: $registry, vsix_pattern: $vsix_pattern, marketplace: $marketplace}')
                
                MATRIX_ENTRIES=$(echo "$MATRIX_ENTRIES" | jq --argjson entry "$ENTRY" '. += [$entry]')
              done
            fi
          done

          # Output the matrix as a single line to avoid formatting issues
          echo "matrix=$(echo "$MATRIX_ENTRIES" | jq -c .)" >> "$GITHUB_OUTPUT"
          echo "Publish matrix: $MATRIX_ENTRIES"

  publish:
    needs:
      [
        bump-versions,
        package,
        create-github-releases,
        calculate-artifact-name,
        determine-publish-matrix,
      ]
    runs-on: ubuntu-latest
    if: needs.determine-publish-matrix.outputs.matrix != '[]'
    strategy:
      matrix:
        include: ${{ fromJson(needs.determine-publish-matrix.outputs.matrix) }}
    steps:
      - name: Audit release attempt
        shell: bash
        run: |
          # Create audit log entry for release attempt
          AUDIT_LOG="/tmp/release_audit.log"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ACTOR="${{ github.actor }}"
          REPO="${{ github.repository }}"
          RUN_ID="${{ github.run_id }}"
          WORKFLOW="${{ github.workflow }}"
          BRANCH="${{ inputs.branch || github.ref_name }}"

          # Log audit information
          echo "[$TIMESTAMP] RELEASE_ATTEMPT: actor=$ACTOR, repo=$REPO, run_id=$RUN_ID, workflow=$WORKFLOW, branch=$BRANCH, registry=${{ matrix.registry }}, marketplace=${{ matrix.marketplace }}, dry_run=${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}" >> "$AUDIT_LOG"

          # Also log to GitHub Actions output for visibility
          echo "üîç AUDIT: Release attempt logged - $TIMESTAMP"
          echo "  Actor: $ACTOR"
          echo "  Repository: $REPO"
          echo "  Run ID: $RUN_ID"
          echo "  Workflow: $WORKFLOW"
          echo "  Branch: $BRANCH"
          echo "  Registry: ${{ matrix.registry }}"
          echo "  Marketplace: ${{ matrix.marketplace }}"
          echo "  Dry-run: ${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ inputs.branch || github.ref }}

      - name: Download VSIX artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.calculate-artifact-name.outputs.artifact-name }}
          path: ./vsix-artifacts

      - name: Debug - List downloaded artifacts
        run: |
          echo "=== DEBUG: Downloaded Artifacts ==="
          echo "Artifact name: ${{ needs.calculate-artifact-name.outputs.artifact-name }}"
          echo "Download path: ./vsix-artifacts"
          echo ""

          if [ -d "./vsix-artifacts" ]; then
            echo "Directory exists. Contents:"
            ls -la ./vsix-artifacts/
            echo ""
            
            echo "VSIX files found:"
            find ./vsix-artifacts -name "*.vsix" -exec ls -la {} \;
            echo ""
            
            echo "Total VSIX files: $(find ./vsix-artifacts -name "*.vsix" | wc -l)"
          else
            echo "‚ùå Directory ./vsix-artifacts does not exist!"
          fi
          echo "=== END DEBUG ==="

      - name: Find VSIX file for publishing
        id: find_vsix
        run: |
          ARTIFACTS_DIR="./vsix-artifacts"
          VSIX_PATTERN="${{ matrix.vsix_pattern }}"
          VSIX_FILE=$(find "$ARTIFACTS_DIR" -name "$VSIX_PATTERN" | head -1)

          if [ -z "$VSIX_FILE" ]; then
            echo "‚ùå No VSIX file found matching pattern: $VSIX_PATTERN"
            echo "Searching in: $ARTIFACTS_DIR"
            echo "Available files:"
            find "$ARTIFACTS_DIR" -name "*.vsix" -exec ls -la {} \;
            exit 1
          fi

          echo "vsix_file=$VSIX_FILE" >> $GITHUB_OUTPUT
          echo "Found VSIX file: $VSIX_FILE"

      - name: Publish to ${{ matrix.marketplace }}
        uses: ./.github/actions/publish-vsix
        env:
          # Pass tokens as environment variables for better security
          VSCE_PERSONAL_ACCESS_TOKEN: ${{ matrix.registry == 'vsce' && secrets.VSCE_PERSONAL_ACCESS_TOKEN || '' }}
          OVSX_PAT: ${{ matrix.registry == 'ovsx' && secrets.OVSX_PAT || '' }}
        with:
          vsix-path: ${{ steps.find_vsix.outputs.vsix_file }}
          publish-tool: ${{ matrix.registry }}
          pre-release: ${{ inputs.pre-release || github.event.inputs.pre-release || 'false' }}
          dry-run: ${{ inputs.dry-run || github.event.inputs.dry-run || 'false' }}

      - name: Audit release result
        shell: bash
        if: inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true'
        run: |
          # Log the result of the release attempt
          AUDIT_LOG="/tmp/release_audit.log"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ACTOR="${{ github.actor }}"
          REPO="${{ github.repository }}"
          RUN_ID="${{ github.run_id }}"
          BRANCH="${{ inputs.branch || github.ref_name }}"

          if [ $? -eq 0 ]; then
            echo "[$TIMESTAMP] RELEASE_SUCCESS: actor=$ACTOR, repo=$REPO, run_id=$RUN_ID, branch=$BRANCH, registry=${{ matrix.registry }}, marketplace=${{ matrix.marketplace }}" >> "$AUDIT_LOG"
            echo "‚úÖ AUDIT: Release successful - $TIMESTAMP"
          else
            echo "[$TIMESTAMP] RELEASE_FAILURE: actor=$ACTOR, repo=$REPO, run_id=$RUN_ID, branch=$BRANCH, registry=${{ matrix.registry }}, marketplace=${{ matrix.marketplace }}" >> "$AUDIT_LOG"
            echo "‚ùå AUDIT: Release failed - $TIMESTAMP"
          fi

  slack-notify:
    name: Slack Notification
    needs: [publish]
    runs-on: ubuntu-latest
    if: always() && needs.publish.result == 'success' && (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}

      - name: Get Extension Details
        id: extension-details
        run: |
          # Get selected extensions and their details
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"
          VERSION_BUMP="${{ needs.determine-build-type.outputs.version-bump }}"
          PRE_RELEASE="${{ needs.determine-build-type.outputs.pre-release }}"

          # Initialize arrays for extension details
          EXTENSION_NAMES=""
          EXTENSION_VERSIONS=""
          EXTENSION_DISPLAY_NAMES=""

          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"
          for ext in "${EXTENSIONS[@]}"; do
            if [ -n "$ext" ] && [ -f "packages/$ext/package.json" ]; then
              # Get package details
              PACKAGE_NAME=$(node -p "require('./packages/$ext/package.json').name")
              PACKAGE_VERSION=$(node -p "require('./packages/$ext/package.json').version")
              DISPLAY_NAME=$(node -p "require('./packages/$ext/package.json').displayName || require('./packages/$ext/package.json').name")
              
              # Add to arrays
              if [ -z "$EXTENSION_NAMES" ]; then
                EXTENSION_NAMES="$PACKAGE_NAME"
                EXTENSION_VERSIONS="$PACKAGE_VERSION"
                EXTENSION_DISPLAY_NAMES="$DISPLAY_NAME"
              else
                EXTENSION_NAMES="$EXTENSION_NAMES, $PACKAGE_NAME"
                EXTENSION_VERSIONS="$EXTENSION_VERSIONS, $PACKAGE_VERSION"
                EXTENSION_DISPLAY_NAMES="$EXTENSION_DISPLAY_NAMES, $DISPLAY_NAME"
              fi
            fi
          done

          echo "extension_names=$EXTENSION_NAMES" >> $GITHUB_OUTPUT
          echo "extension_versions=$EXTENSION_VERSIONS" >> $GITHUB_OUTPUT
          echo "extension_display_names=$EXTENSION_DISPLAY_NAMES" >> $GITHUB_OUTPUT
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "pre_release=$PRE_RELEASE" >> $GITHUB_OUTPUT

      - name: Notify Slack
        uses: slackapi/slack-github-action@v1.22.0
        with:
          payload: |
            {
              "text": "üéâ VS Code Extensions Released Successfully!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üéâ VS Code Extensions Released Successfully!"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ inputs.branch || github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Extensions:*\n${{ steps.extension-details.outputs.extension_display_names }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Versions:*\n${{ steps.extension-details.outputs.extension_versions }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Release Type:*\n${{ steps.extension-details.outputs.pre_release == 'true' && 'Pre-release' || 'Stable' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Version Bump:*\n${{ steps.extension-details.outputs.version_bump }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Workflow Run:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.IDEE_MAIN_SLACK_WEBHOOK }}

  slack-notify-failure:
    name: Slack Failure Notification
    needs: [publish]
    runs-on: ubuntu-latest
    if: always() && needs.publish.result == 'failure' && (inputs.dry-run != 'true' && github.event.inputs.dry-run != 'true')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}

      - name: Get Extension Details
        id: extension-details
        run: |
          # Get selected extensions and their details
          SELECTED_EXTENSIONS="${{ needs.determine-changes.outputs.selected-extensions }}"
          VERSION_BUMP="${{ needs.determine-build-type.outputs.version-bump }}"
          PRE_RELEASE="${{ needs.determine-build-type.outputs.pre-release }}"

          # Initialize arrays for extension details
          EXTENSION_NAMES=""
          EXTENSION_VERSIONS=""
          EXTENSION_DISPLAY_NAMES=""

          IFS=',' read -ra EXTENSIONS <<< "$SELECTED_EXTENSIONS"
          for ext in "${EXTENSIONS[@]}"; do
            if [ -n "$ext" ] && [ -f "packages/$ext/package.json" ]; then
              # Get package details
              PACKAGE_NAME=$(node -p "require('./packages/$ext/package.json').name")
              PACKAGE_VERSION=$(node -p "require('./packages/$ext/package.json').version")
              DISPLAY_NAME=$(node -p "require('./packages/$ext/package.json').displayName || require('./packages/$ext/package.json').name")
              
              # Add to arrays
              if [ -z "$EXTENSION_NAMES" ]; then
                EXTENSION_NAMES="$PACKAGE_NAME"
                EXTENSION_VERSIONS="$PACKAGE_VERSION"
                EXTENSION_DISPLAY_NAMES="$DISPLAY_NAME"
              else
                EXTENSION_NAMES="$EXTENSION_NAMES, $PACKAGE_NAME"
                EXTENSION_VERSIONS="$EXTENSION_VERSIONS, $PACKAGE_VERSION"
                EXTENSION_DISPLAY_NAMES="$EXTENSION_DISPLAY_NAMES, $DISPLAY_NAME"
              fi
            fi
          done

          echo "extension_names=$EXTENSION_NAMES" >> $GITHUB_OUTPUT
          echo "extension_versions=$EXTENSION_VERSIONS" >> $GITHUB_OUTPUT
          echo "extension_display_names=$EXTENSION_DISPLAY_NAMES" >> $GITHUB_OUTPUT
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "pre_release=$PRE_RELEASE" >> $GITHUB_OUTPUT

      - name: Notify Slack
        uses: slackapi/slack-github-action@v1.22.0
        with:
          payload: |
            {
              "text": "‚ùå VS Code Extension Release Failed!",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "‚ùå VS Code Extension Release Failed!"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Repository:*\n${{ github.repository }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ inputs.branch || github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Extensions:*\n${{ steps.extension-details.outputs.extension_display_names }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Versions:*\n${{ steps.extension-details.outputs.extension_versions }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Release Type:*\n${{ steps.extension-details.outputs.pre_release == 'true' && 'Pre-release' || 'Stable' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Version Bump:*\n${{ steps.extension-details.outputs.version_bump }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Workflow Run:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "Please check the workflow logs for detailed error information."
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.IDEE_MAIN_SLACK_WEBHOOK }}
